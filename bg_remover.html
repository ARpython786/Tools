// Main application class
class BackgroundRemover {
    constructor() {
        // DOM elements
        this.uploadZone = document.getElementById('uploadZone');
        this.fileInput = document.getElementById('fileInput');
        this.processingArea = document.getElementById('processingArea');
        this.actionButtons = document.getElementById('actionButtons');
        this.originalCanvas = document.getElementById('originalCanvas');
        this.processedCanvas = document.getElementById('processedCanvas');
        this.smartPreviewToggle = document.getElementById('smartPreviewToggle');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.newImageBtn = document.getElementById('newImageBtn');
        this.loadingOverlay = document.getElementById('loadingOverlay');
        this.loadingSubtext = document.getElementById('loadingSubtext');
        this.errorModal = document.getElementById('errorModal');
        this.errorTitle = document.getElementById('errorTitle');
        this.errorMessage = document.getElementById('errorMessage');
        this.tryAgainBtn = document.getElementById('tryAgainBtn');
        this.uploadNewBtn = document.getElementById('uploadNewBtn');
        this.modalClose = document.getElementById('modalClose');
        this.successModal = document.getElementById('successModal');
        this.successModalClose = document.getElementById('successModalClose');
        this.downloadNowBtn = document.getElementById('downloadNowBtn');
        this.editMoreBtn = document.getElementById('editMoreBtn');
        
        // Tool elements
        this.keepBrush = document.getElementById('keepBrush');
        this.removeBrush = document.getElementById('removeBrush');
        this.brushSize = document.getElementById('brushSize');
        this.brushSizeValue = document.getElementById('brushSizeValue');
        this.edgeSmoothness = document.getElementById('edgeSmoothness');
        this.edgeSmoothnessValue = document.getElementById('edgeSmoothnessValue');
        this.edgeFeather = document.getElementById('edgeFeather');
        this.edgeFeatherValue = document.getElementById('edgeFeatherValue');
        this.contrast = document.getElementById('contrast');
        this.contrastValue = document.getElementById('contrastValue');
        this.watermarkToggle = document.getElementById('watermarkToggle');
        this.watermarkSettings = document.getElementById('watermarkSettings');
        this.watermarkText = document.getElementById('watermarkText');
        this.watermarkColor = document.getElementById('watermarkColor');
        this.watermarkOpacity = document.getElementById('watermarkOpacity');
        this.watermarkOpacityValue = document.getElementById('watermarkOpacityValue');
        this.watermarkTypeRadios = document.querySelectorAll('input[name="watermarkType"]');
        this.watermarkImageInput = document.getElementById('watermarkImageInput');
        this.undoBtn = document.getElementById('undoBtn');
        this.redoBtn = document.getElementById('redoBtn');
        this.resetBtn = document.getElementById('resetBtn');
        
        // Sample images
        this.sampleImages = document.querySelectorAll('.sample-img');
        
        // Canvas contexts
        this.originalCtx = this.originalCanvas.getContext('2d');
        this.processedCtx = this.processedCanvas.getContext('2d');
        
        // State variables
        this.currentImage = null;
        this.originalImageData = null;
        this.processedImageData = null;
        this.maskData = null;
        this.currentTool = 'keep'; // 'keep' or 'remove'
        this.brushSizeValue = 20;
        this.zoomLevel = 1;
        this.zoomOffsetX = 0;
        this.zoomOffsetY = 0;
        this.isDragging = false;
        this.lastX = 0;
        this.lastY = 0;
        this.actionHistory = [];
        this.currentHistoryIndex = -1;
        this.isProcessing = false;
        
        // TensorFlow.js model
        this.model = null;
        this.modelLoading = false;
        
        // Initialize the application
        this.initEventListeners();
        this.loadModel();
    }
    
    // Initialize event listeners
    initEventListeners() {
        // Upload zone events
        this.uploadZone.addEventListener('click', () => this.fileInput.click());
        this.uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            this.uploadZone.classList.add('dragover');
        });
        this.uploadZone.addEventListener('dragleave', () => {
            this.uploadZone.classList.remove('dragover');
        });
        this.uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            this.uploadZone.classList.remove('dragover');
            if (e.dataTransfer.files.length) {
                this.handleFileUpload(e.dataTransfer.files[0]);
            }
        });
        
        // File input change
        this.fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                this.handleFileUpload(e.target.files[0]);
            }
        });
        
        // Sample images
        this.sampleImages.forEach(img => {
            img.addEventListener('click', (e) => {
                const sample = e.target.getAttribute('data-sample');
                this.loadSampleImage(sample);
            });
        });
        
        // Smart preview toggle
        this.smartPreviewToggle.addEventListener('change', () => {
            this.updateCanvasPreview();
        });
        
        // Download button
        this.downloadBtn.addEventListener('click', () => this.downloadImage());
        this.downloadNowBtn.addEventListener('click', () => this.downloadImage());
        
        // New image button
        this.newImageBtn.addEventListener('click', () => this.resetTool());
        this.uploadNewBtn.addEventListener('click', () => {
            this.errorModal.classList.add('hidden');
            this.resetTool();
        });
        this.editMoreBtn.addEventListener('click', () => {
            this.successModal.classList.add('hidden');
        });
        
        // Try again button
        this.tryAgainBtn.addEventListener('click', () => {
            this.errorModal.classList.add('hidden');
            this.processImageWithFallback();
        });
        
        // Modal close buttons
        this.modalClose.addEventListener('click', () => {
            this.errorModal.classList.add('hidden');
        });
        this.successModalClose.addEventListener('click', () => {
            this.successModal.classList.add('hidden');
        });
        
        // Tool buttons
        this.keepBrush.addEventListener('click', () => {
            this.currentTool = 'keep';
            this.keepBrush.classList.add('active');
            this.removeBrush.classList.remove('active');
        });
        
        this.removeBrush.addEventListener('click', () => {
            this.currentTool = 'remove';
            this.removeBrush.classList.add('active');
            this.keepBrush.classList.remove('active');
        });
        
        // Brush size slider
        this.brushSize.addEventListener('input', (e) => {
            this.brushSizeValue = e.target.value;
            this.brushSizeValue.textContent = this.brushSizeValue;
        });
        
        // Edge refinement sliders
        this.edgeSmoothness.addEventListener('input', (e) => {
            this.edgeSmoothnessValue.textContent = e.target.value;
            this.applyEdgeRefinement();
        });
        
        this.edgeFeather.addEventListener('input', (e) => {
            this.edgeFeatherValue.textContent = e.target.value;
            this.applyEdgeRefinement();
        });
        
        this.contrast.addEventListener('input', (e) => {
            this.contrastValue.textContent = e.target.value;
            this.applyEdgeRefinement();
        });
        
        // Watermark toggle
        this.watermarkToggle.addEventListener('change', () => {
            this.watermarkSettings.classList.toggle('hidden', !this.watermarkToggle.checked);
            this.updateCanvasPreview();
        });
        
        // Watermark type change
        this.watermarkTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                document.querySelector('.watermark-text-settings').classList.toggle('hidden', radio.value !== 'text');
                document.querySelector('.watermark-image-settings').classList.toggle('hidden', radio.value !== 'image');
                this.updateCanvasPreview();
            });
        });
        
        // Watermark settings changes
        this.watermarkText.addEventListener('input', () => this.updateCanvasPreview());
        this.watermarkColor.addEventListener('input', () => this.updateCanvasPreview());
        this.watermarkOpacity.addEventListener('input', (e) => {
            this.watermarkOpacityValue.textContent = `${e.target.value}%`;
            this.updateCanvasPreview();
        });
        this.watermarkImageInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                this.loadWatermarkImage(e.target.files[0]);
            }
        });
        
        // Undo/redo/reset buttons
        this.undoBtn.addEventListener('click', () => this.undoAction());
        this.redoBtn.addEventListener('click', () => this.redoAction());
        this.resetBtn.addEventListener('click', () => this.resetMask());
        
        // Canvas mouse events for brushing
        this.processedCanvas.addEventListener('mousedown', (e) => {
            if (!this.processedImageData) return;
            
            this.isDragging = true;
            this.lastX = e.offsetX;
            this.lastY = e.offsetY;
            this.applyBrush(e.offsetX, e.offsetY);
            
            // Save state for undo
            this.saveState();
        });
        
        this.processedCanvas.addEventListener('mousemove', (e) => {
            if (!this.isDragging || !this.processedImageData) return;
            
            this.applyBrush(e.offsetX, e.offsetY);
            this.lastX = e.offsetX;
            this.lastY = e.offsetY;
        });
        
        this.processedCanvas.addEventListener('mouseup', () => {
            this.isDragging = false;
        });
        
        this.processedCanvas.addEventListener('mouseleave', () => {
            this.isDragging = false;
        });
        
        // Touch events for mobile
        this.processedCanvas.addEventListener('touchstart', (e) => {
            if (!this.processedImageData) return;
            
            e.preventDefault();
            const rect = this.processedCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            this.isDragging = true;
            this.lastX = x;
            this.lastY = y;
            this.applyBrush(x, y);
            
            // Save state for undo
            this.saveState();
        });
        
        this.processedCanvas.addEventListener('touchmove', (e) => {
            if (!this.isDragging || !this.processedImageData) return;
            
            e.preventDefault();
            const rect = this.processedCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            this.applyBrush(x, y);
            this.lastX = x;
            this.lastY = y;
        });
        
        this.processedCanvas.addEventListener('touchend', () => {
            this.isDragging = false;
        });
        
        // Zoom controls
        document.querySelector('.zoom-in').addEventListener('click', () => this.adjustZoom(1.2));
        document.querySelector('.zoom-out').addEventListener('click', () => this.adjustZoom(0.8));
        document.querySelector('.zoom-reset').addEventListener('click', () => this.resetZoom());
        
        // Panning
        this.processedCanvas.addEventListener('mousedown', (e) => {
            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) { // Middle mouse or Ctrl+Left mouse
                e.preventDefault();
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.processedCanvas.style.cursor = 'grabbing';
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (this.isDragging && (e.buttons === 4 || (e.buttons === 1 && e.ctrlKey))) {
                e.preventDefault();
                const dx = e.clientX - this.lastX;
                const dy = e.clientY - this.lastY;
                
                this.zoomOffsetX += dx;
                this.zoomOffsetY += dy;
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateCanvasPreview();
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (this.isDragging) {
                this.isDragging = false;
                this.processedCanvas.style.cursor = '';
            }
        });
    }
    
    // Load TensorFlow.js model
    async loadModel() {
        if (this.modelLoading || this.model) return;
        
        this.modelLoading = true;
        this.loadingSubtext.textContent = 'Loading AI model...';
        
        try {
            // Load BodyPix model - good for person segmentation
            // For general purpose, you might want to use a different model
            this.model = await bodyPix.load({
                architecture: 'MobileNetV1',
                outputStride: 16,
                multiplier: 0.75,
                quantBytes: 2
            });
            
            console.log('Model loaded successfully');
        } catch (error) {
            console.error('Error loading model:', error);
            this.showError('Model Loading Failed', 'The AI model failed to load. The tool will use a simpler method for background removal.');
        } finally {
            this.modelLoading = false;
        }
    }
    
    // Handle file upload
    async handleFileUpload(file) {
        // Validate file
        if (!file.type.match('image.*')) {
            this.showError('Invalid File', 'Please upload an image file (JPG, PNG, or WEBP).');
            return;
        }
        
        if (file.size > 25 * 1024 * 1024) { // 25MB limit
            this.showError('File Too Large', 'Please upload an image smaller than 25MB.');
            return;
        }
        
        // Show loading state
        this.showLoading('Processing your image...');
        
        try {
            // Read the image file
            const img = await this.loadImageFile(file);
            this.currentImage = img;
            
            // Set canvas dimensions
            this.setCanvasDimensions(img.width, img.height);
            
            // Draw original image
            this.originalCtx.drawImage(img, 0, 0);
            this.originalImageData = this.originalCtx.getImageData(0, 0, this.originalCanvas.width, this.originalCanvas.height);
            
            // Process the image to remove background
            await this.processImage();
            
            // Show the processing area
            this.uploadZone.classList.add('hidden');
            this.processingArea.classList.remove('hidden');
            this.actionButtons.classList.remove('hidden');
            
            // Reset zoom
            this.resetZoom();
            
            // Hide loading
            this.hideLoading();
        } catch (error) {
            console.error('Error processing image:', error);
            this.hideLoading();
            this.showError('Processing Error', 'There was an error processing your image. Please try again with a different image.');
        }
    }
    
    // Load image file
    loadImageFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }
    
    // Set canvas dimensions
    setCanvasDimensions(imgWidth, imgHeight) {
        // Calculate dimensions to fit in the preview area while maintaining aspect ratio
        const maxWidth = window.innerWidth > 768 ? 600 : 300;
        const maxHeight = 400;
        
        let width = imgWidth;
        let height = imgHeight;
        
        if (width > maxWidth) {
            const ratio = maxWidth / width;
            width = maxWidth;
            height = height * ratio;
        }
        
        if (height > maxHeight) {
            const ratio = maxHeight / height;
            height = maxHeight;
            width = width * ratio;
        }
        
        // Set canvas dimensions
        this.originalCanvas.width = width;
        this.originalCanvas.height = height;
        this.processedCanvas.width = width;
        this.processedCanvas.height = height;
    }
    
    // Process image to remove background
    async processImage() {
        if (!this.currentImage) return;
        
        this.isProcessing = true;
        
        try {
            // Try with AI first
            await this.processImageWithAI();
            
            // If AI fails, fall back to simpler method
            if (!this.processedImageData) {
                await this.processImageWithFallback();
            }
            
            // Update the canvas preview
            this.updateCanvasPreview();
            
            // Save initial state for undo/redo
            this.saveState();
        } catch (error) {
            console.error('Error in processImage:', error);
            throw error;
        } finally {
            this.isProcessing = false;
        }
    }
    
    // Process image using AI (TensorFlow.js)
    async processImageWithAI() {
        if (!this.model) {
            console.log('AI model not loaded, using fallback method');
            return this.processImageWithFallback();
        }
        
        try {
            // Perform segmentation
            const segmentation = await this.model.segmentPerson(this.currentImage, {
                flipHorizontal: false,
                internalResolution: 'high',
                segmentationThreshold: 0.7,
                maxDetections: 1
            });
            
            // Create mask from segmentation
            const mask = segmentation.data;
            const width = segmentation.width;
            const height = segmentation.height;
            
            // Create a new ImageData for the processed image
            const originalData = this.originalImageData.data;
            const processedData = new Uint8ClampedArray(originalData.length);
            
            // Apply mask to create transparent background
            for (let i = 0; i < mask.length; i++) {
                const pixelPos = i * 4;
                
                if (mask[i] === 1) { // Person (keep)
                    processedData[pixelPos] = originalData[pixelPos];     // R
                    processedData[pixelPos + 1] = originalData[pixelPos + 1]; // G
                    processedData[pixelPos + 2] = originalData[pixelPos + 2]; // B
                    processedData[pixelPos + 3] = 255; // A (fully opaque)
                } else { // Background (remove)
                    processedData[pixelPos] = 0;     // R
                    processedData[pixelPos + 1] = 0; // G
                    processedData[pixelPos + 2] = 0; // B
                    processedData[pixelPos + 3] = 0; // A (fully transparent)
                }
            }
            
            // Store the processed image data
            this.processedImageData = new ImageData(processedData, width, height);
            this.maskData = new Uint8Array(mask);
            
            return true;
        } catch (error) {
            console.error('AI processing failed:', error);
            return false;
        }
    }
    
    // Process image using simpler color-based method
    async processImageWithFallback() {
        if (!this.currentImage) return;
        
        try {
            const originalData = this.originalImageData.data;
            const processedData = new Uint8ClampedArray(originalData.length);
            const maskData = new Uint8Array(originalData.length / 4);
            
            // Simple background removal based on color difference from edges
            // This is a simplified approach - in a real app you'd want something more sophisticated
            
            // Sample edge colors to determine likely background
            const edgeColors = this.sampleEdgeColors(originalData, this.originalImageData.width, this.originalImageData.height);
            
            // Calculate average edge color
            const avgColor = this.calculateAverageColor(edgeColors);
            
            // Threshold for background detection
            const threshold = 30;
            
            // Create mask
            for (let i = 0; i < originalData.length; i += 4) {
                const r = originalData[i];
                const g = originalData[i + 1];
                const b = originalData[i + 2];
                
                // Calculate color difference from average edge color
                const diff = Math.sqrt(
                    Math.pow(r - avgColor.r, 2) +
                    Math.pow(g - avgColor.g, 2) +
                    Math.pow(b - avgColor.b, 2)
                );
                
                const maskPos = i / 4;
                
                if (diff < threshold) {
                    // Background - make transparent
                    processedData[i] = 0;
                    processedData[i + 1] = 0;
                    processedData[i + 2] = 0;
                    processedData[i + 3] = 0;
                    maskData[maskPos] = 0;
                } else {
                    // Foreground - keep original
                    processedData[i] = r;
                    processedData[i + 1] = g;
                    processedData[i + 2] = b;
                    processedData[i + 3] = 255;
                    maskData[maskPos] = 1;
                }
            }
            
            // Store the processed image data
            this.processedImageData = new ImageData(processedData, this.originalImageData.width, this.originalImageData.height);
            this.maskData = maskData;
            
            return true;
        } catch (error) {
            console.error('Fallback processing failed:', error);
            return false;
        }
    }
    
    // Sample edge colors to determine likely background
    sampleEdgeColors(imageData, width, height) {
        const edgeColors = [];
        const edgeWidth = 5; // Sample from 5-pixel border
        
        // Top edge
        for (let y = 0; y < edgeWidth; y++) {
            for (let x = 0; x < width; x++) {
                const pos = (y * width + x) * 4;
                edgeColors.push({
                    r: imageData[pos],
                    g: imageData[pos + 1],
                    b: imageData[pos + 2]
                });
            }
        }
        
        // Bottom edge
        for (let y = height - edgeWidth; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const pos = (y * width + x) * 4;
                edgeColors.push({
                    r: imageData[pos],
                    g: imageData[pos + 1],
                    b: imageData[pos + 2]
                });
            }
        }
        
        // Left edge
        for (let y = edgeWidth; y < height - edgeWidth; y++) {
            for (let x = 0; x < edgeWidth; x++) {
                const pos = (y * width + x) * 4;
                edgeColors.push({
                    r: imageData[pos],
                    g: imageData[pos + 1],
                    b: imageData[pos + 2]
                });
            }
        }
        
        // Right edge
        for (let y = edgeWidth; y < height - edgeWidth; y++) {
            for (let x = width - edgeWidth; x < width; x++) {
                const pos = (y * width + x) * 4;
                edgeColors.push({
                    r: imageData[pos],
                    g: imageData[pos + 1],
                    b: imageData[pos + 2]
                });
            }
        }
        
        return edgeColors;
    }
    
    // Calculate average color from an array of colors
    calculateAverageColor(colors) {
        let r = 0, g = 0, b = 0;
        
        for (const color of colors) {
            r += color.r;
            g += color.g;
            b += color.b;
        }
        
        return {
            r: Math.round(r / colors.length),
            g: Math.round(g / colors.length),
            b: Math.round(b / colors.length)
        };
    }
    
    // Update canvas preview
    updateCanvasPreview() {
        if (!this.processedImageData) return;
        
        // Clear canvas
        this.processedCtx.clearRect(0, 0, this.processedCanvas.width, this.processedCanvas.height);
        
        // Apply zoom and pan transformations
        this.processedCtx.save();
        this.processedCtx.translate(this.zoomOffsetX, this.zoomOffsetY);
        this.processedCtx.scale(this.zoomLevel, this.zoomLevel);
        
        // Draw checkerboard background for transparency
        this.drawCheckerboard();
        
        // Draw the processed image
        this.processedCtx.putImageData(this.processedImageData, 0, 0);
        
        // Apply watermark if enabled
        if (this.watermarkToggle.checked) {
            this.applyWatermark();
        }
        
        // Restore transformations
        this.processedCtx.restore();
        
        // If smart preview is on, show original in the processed canvas
        if (this.smartPreviewToggle.checked) {
            this.processedCtx.globalAlpha = 0.5;
            this.processedCtx.drawImage(this.originalCanvas, 0, 0);
            this.processedCtx.globalAlpha = 1.0;
        }
    }
    
    // Draw checkerboard pattern for transparency
    drawCheckerboard() {
        const size = 20;
        const rows = Math.ceil(this.processedCanvas.height / size);
        const cols = Math.ceil(this.processedCanvas.width / size);
        
        this.processedCtx.fillStyle = '#e5e5e5';
        this.processedCtx.fillRect(0, 0, this.processedCanvas.width, this.processedCanvas.height);
        
        this.processedCtx.fillStyle = '#cccccc';
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if ((x + y) % 2 === 0) {
                    this.processedCtx.fillRect(
                        x * size, 
                        y * size, 
                        size, 
                        size
                    );
                }
            }
        }
    }
    
    // Apply watermark to the image
    applyWatermark() {
        const watermarkType = document.querySelector('input[name="watermarkType"]:checked').value;
        
        if (watermarkType === 'text') {
            this.applyTextWatermark();
        } else if (watermarkType === 'image' && this.watermarkImage) {
            this.applyImageWatermark();
        }
    }
    
    // Apply text watermark
    applyTextWatermark() {
        const text = this.watermarkText.value || 'ProCut';
        const color = this.watermarkColor.value;
        const opacity = parseInt(this.watermarkOpacity.value) / 100;
        
        this.processedCtx.save();
        this.processedCtx.globalAlpha = opacity;
        this.processedCtx.fillStyle = color;
        this.processedCtx.font = 'bold 24px Arial';
        this.processedCtx.textAlign = 'center';
        this.processedCtx.textBaseline = 'middle';
        
        // Calculate position (center)
        const x = this.processedCanvas.width / 2;
        const y = this.processedCanvas.height / 2;
        
        // Add text shadow for better visibility
        this.processedCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        this.processedCtx.shadowBlur = 5;
        this.processedCtx.shadowOffsetX = 2;
        this.processedCtx.shadowOffsetY = 2;
        
        this.processedCtx.fillText(text, x, y);
        this.processedCtx.restore();
    }
    
    // Apply image watermark
    applyImageWatermark() {
        if (!this.watermarkImage) return;
        
        const opacity = parseInt(this.watermarkOpacity.value) / 100;
        
        // Calculate dimensions (20% of canvas width, maintain aspect ratio)
        const maxWidth = this.processedCanvas.width * 0.2;
        const ratio = maxWidth / this.watermarkImage.width;
        const width = maxWidth;
        const height = this.watermarkImage.height * ratio;
        
        // Position (bottom right with 10px margin)
        const x = this.processedCanvas.width - width - 10;
        const y = this.processedCanvas.height - height - 10;
        
        this.processedCtx.save();
        this.processedCtx.globalAlpha = opacity;
        this.processedCtx.drawImage(this.watermarkImage, x, y, width, height);
        this.processedCtx.restore();
    }
    
    // Load watermark image
    loadWatermarkImage(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            this.watermarkImage = new Image();
            this.watermarkImage.onload = () => {
                this.updateCanvasPreview();
            };
            this.watermarkImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
    
    // Load sample image
    loadSampleImage(sampleId) {
        this.showLoading('Loading sample image...');
        
        // In a real app, you would have actual sample images
        // For this demo, we'll just use a placeholder
        const img = new Image();
        img.onload = () => {
            this.currentImage = img;
            this.setCanvasDimensions(img.width, img.height);
            this.originalCtx.drawImage(img, 0, 0);
            this.originalImageData = this.originalCtx.getImageData(0, 0, this.originalCanvas.width, this.originalCanvas.height);
            
            // Process the image
            this.processImage().then(() => {
                this.uploadZone.classList.add('hidden');
                this.processingArea.classList.remove('hidden');
                this.actionButtons.classList.remove('hidden');
                this.resetZoom();
                this.hideLoading();
            });
        };
        
        // Placeholder sample image URL - replace with your actual sample images
        img.src = `https://example.com/samples/${sampleId}.jpg`;
    }
    
    // Apply brush to mask
    applyBrush(x, y) {
        if (!this.maskData || !this.processedImageData) return;
        
        // Adjust coordinates for zoom and pan
        const adjustedX = (x - this.zoomOffsetX) / this.zoomLevel;
        const adjustedY = (y - this.zoomOffsetY) / this.zoomLevel;
        
        const width = this.processedCanvas.width;
        const height = this.processedCanvas.height;
        const radius = this.brushSizeValue / 2;
        const radiusSq = radius * radius;
        
        const originalData = this.originalImageData.data;
        const processedData = this.processedImageData.data;
        
        // Convert coordinates to image data coordinates
        const imgX = Math.round(adjustedX);
        const imgY = Math.round(adjustedY);
        
        // Iterate through pixels in a circular area around the brush position
        for (let y = Math.max(0, imgY - radius); y < Math.min(height, imgY + radius); y++) {
            for (let x = Math.max(0, imgX - radius); x < Math.min(width, imgX + radius); x++) {
                const distSq = (x - imgX) * (x - imgX) + (y - imgY) * (y - imgY);
                
                if (distSq <= radiusSq) {
                    const pos = (y * width + x) * 4;
                    const maskPos = y * width + x;
                    
                    if (this.currentTool === 'keep') {
                        // Keep this pixel (copy from original)
                        processedData[pos] = originalData[pos];
                        processedData[pos + 1] = originalData[pos + 1];
                        processedData[pos + 2] = originalData[pos + 2];
                        processedData[pos + 3] = 255;
                        this.maskData[maskPos] = 1;
                    } else {
                        // Remove this pixel (make transparent)
                        processedData[pos] = 0;
                        processedData[pos + 1] = 0;
                        processedData[pos + 2] = 0;
                        processedData[pos + 3] = 0;
                        this.maskData[maskPos] = 0;
                    }
                }
            }
        }
        
        // Update the canvas
        this.updateCanvasPreview();
    }
    
    // Apply edge refinement
    applyEdgeRefinement() {
        if (!this.processedImageData || !this.originalImageData) return;
        
        // Get slider values
        const smoothness = parseInt(this.edgeSmoothness.value) / 100;
        const feather = parseInt(this.edgeFeather.value) / 100;
        const contrast = parseInt(this.contrast.value) / 50; // 0-2 range
        
        // Create a copy of the original image data
        const width = this.processedCanvas.width;
        const height = this.processedCanvas.height;
        const originalData = this.originalImageData.data;
        const processedData = new Uint8ClampedArray(this.processedImageData.data);
        
        // Apply edge refinement
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const pos = (y * width + x) * 4;
                const maskPos = y * width + x;
                
                // Only process edge pixels (where mask transitions from 0 to 1 or vice versa)
                if (this.maskData[maskPos] === 1) {
                    let isEdge = false;
                    
                    // Check 8 surrounding pixels
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const neighborPos = ((y + dy) * width + (x + dx)) * 4;
                            const neighborMaskPos = (y + dy) * width + (x + dx);
                            
                            if (this.maskData[neighborMaskPos] === 0) {
                                isEdge = true;
                                break;
                            }
                        }
                        if (isEdge) break;
                    }
                    
                    if (isEdge) {
                        // Apply smoothing
                        if (smoothness > 0) {
                            let r = 0, g = 0, b = 0, count = 0;
                            
                            // Average with surrounding pixels
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    
                                    const neighborPos = ((y + dy) * width + (x + dx)) * 4;
                                    
                                    r += originalData[neighborPos];
                                    g += originalData[neighborPos + 1];
                                    b += originalData[neighborPos + 2];
                                    count++;
                                }
                            }
                            
                            // Blend with original based on smoothness
                            processedData[pos] = Math.round(originalData[pos] * (1 - smoothness) + (r / count) * smoothness);
                            processedData[pos + 1] = Math.round(originalData[pos + 1] * (1 - smoothness) + (g / count) * smoothness);
                            processedData[pos + 2] = Math.round(originalData[pos + 2] * (1 - smoothness) + (b / count) * smoothness);
                        }
                        
                        // Apply feathering (alpha transition)
                        if (feather > 0) {
                            // Find distance to nearest background pixel
                            let minDist = Infinity;
                            
                            for (let dy = -3; dy <= 3; dy++) {
                                for (let dx = -3; dx <= 3; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    
                                    const neighborMaskPos = (y + dy) * width + (x + dx);
                                    
                                    if (neighborMaskPos >= 0 && neighborMaskPos < this.maskData.length && 
                                        this.maskData[neighborMaskPos] === 0) {
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < minDist) minDist = dist;
                                    }
                                }
                            }
                            
                            if (minDist < Infinity) {
                                // Adjust alpha based on distance
                                const alpha = Math.min(1, minDist / 3); // 0-1 range
                                processedData[pos + 3] = Math.round(255 * Math.pow(alpha, 1 - feather));
                            }
                        }
                        
                        // Apply contrast
                        if (contrast !== 1) {
                            // Simple contrast adjustment
                            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                            
                            processedData[pos] = this.clamp(factor * (processedData[pos] - 128) + 128, 0, 255);
                            processedData[pos + 1] = this.clamp(factor * (processedData[pos + 1] - 128) + 128, 0, 255);
                            processedData[pos + 2] = this.clamp(factor * (processedData[pos + 2] - 128) + 128, 0, 255);
                        }
                    }
                }
            }
        }
        
        // Update the processed image data
        this.processedImageData = new ImageData(processedData, width, height);
        
        // Update the canvas
        this.updateCanvasPreview();
    }
    
    // Clamp value between min and max
    clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
    
    // Adjust zoom level
    adjustZoom(factor) {
        this.zoomLevel *= factor;
        
        // Limit zoom
        this.zoomLevel = Math.max(0.1, Math.min(this.zoomLevel, 10));
        
        this.updateCanvasPreview();
    }
    
    // Reset zoom and pan
    resetZoom() {
        this.zoomLevel = 1;
        this.zoomOffsetX = 0;
        this.zoomOffsetY = 0;
        this.updateCanvasPreview();
    }
    
    // Save current state for undo/redo
    saveState() {
        if (!this.processedImageData) return;
        
        // Remove any states after current position in history
        if (this.currentHistoryIndex < this.actionHistory.length - 1) {
            this.actionHistory = this.actionHistory.slice(0, this.currentHistoryIndex + 1);
        }
        
        // Create copies of the current state
        const processedDataCopy = new Uint8ClampedArray(this.processedImageData.data);
        const maskDataCopy = new Uint8Array(this.maskData);
        
        // Add to history
        this.actionHistory.push({
            processedData: new ImageData(processedDataCopy, this.processedImageData.width, this.processedImageData.height),
            maskData: maskDataCopy
        });
        
        // Limit history size
        if (this.actionHistory.length > 20) {
            this.actionHistory.shift();
        } else {
            this.currentHistoryIndex = this.actionHistory.length - 1;
        }
        
        // Update undo/redo button states
        this.updateUndoRedoButtons();
    }
    
    // Undo last action
    undoAction() {
        if (this.currentHistoryIndex <= 0) return;
        
        this.currentHistoryIndex--;
        this.restoreFromHistory();
    }
    
    // Redo last undone action
    redoAction() {
        if (this.currentHistoryIndex >= this.actionHistory.length - 1) return;
        
        this.currentHistoryIndex++;
        this.restoreFromHistory();
    }
    
    // Restore state from history
    restoreFromHistory() {
        const state = this.actionHistory[this.currentHistoryIndex];
        
        // Create new copies to avoid reference issues
        this.processedImageData = new ImageData(
            new Uint8ClampedArray(state.processedData.data),
            state.processedData.width,
            state.processedData.height
        );
        
        this.maskData = new Uint8Array(state.maskData);
        
        // Update the canvas
        this.updateCanvasPreview();
        
        // Update undo/redo button states
        this.updateUndoRedoButtons();
    }
    
    // Update undo/redo button states
    updateUndoRedoButtons() {
        this.undoBtn.disabled = this.currentHistoryIndex <= 0;
        this.redoBtn.disabled = this.currentHistoryIndex >= this.actionHistory.length - 1;
    }
    
    // Reset mask (keep original image)
    resetMask() {
        if (!this.originalImageData) return;
        
        // Create a new mask that keeps everything
        this.maskData = new Uint8Array(this.originalImageData.data.length / 4).fill(1);
        
        // Create processed image from original
        const processedData = new Uint8ClampedArray(this.originalImageData.data);
        this.processedImageData = new ImageData(processedData, this.originalImageData.width, this.originalImageData.height);
        
        // Save state
        this.saveState();
        
        // Update the canvas
        this.updateCanvasPreview();
    }
    
    // Download the processed image
    downloadImage() {
        if (!this.processedImageData) return;
        
        try {
            // Create a temporary canvas at the original image dimensions
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Set to original image dimensions for full resolution
            tempCanvas.width = this.currentImage.width;
            tempCanvas.height = this.currentImage.height;
            
            // Draw checkerboard background
            this.drawCheckerboardOnCanvas(tempCtx, tempCanvas.width, tempCanvas.height);
            
            // Draw the original image on the temp canvas
            tempCtx.drawImage(this.currentImage, 0, 0);
            
            // Apply the mask from the processed image
            const maskCanvas = document.createElement('canvas');
            const maskCtx = maskCanvas.getContext('2d');
            maskCanvas.width = this.processedCanvas.width;
            maskCanvas.height = this.processedCanvas.height;
            
            // Put the processed image data (which has transparency) on the mask canvas
            maskCtx.putImageData(this.processedImageData, 0, 0);
            
            // Draw the mask onto the temp canvas with proper scaling
            tempCtx.save();
            tempCtx.globalCompositeOperation = 'destination-in';
            tempCtx.drawImage(
                maskCanvas, 
                0, 0, maskCanvas.width, maskCanvas.height,
                0, 0, tempCanvas.width, tempCanvas.height
            );
            tempCtx.restore();
            
            // Apply watermark if enabled
            if (this.watermarkToggle.checked) {
                this.applyWatermarkToCanvas(tempCtx, tempCanvas.width, tempCanvas.height);
            }
            
            // Create filename
            let filename = 'image_transparent.png';
            if (this.fileInput.files.length) {
                const originalName = this.fileInput.files[0].name.split('.')[0];
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                filename = `${originalName}_transparent_${timestamp}.png`;
            }
            
            // Convert to data URL and download
            const dataURL = tempCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            link.click();
            
            // Show success modal
            this.successModal.classList.remove('hidden');
        } catch (error) {
            console.error('Error downloading image:', error);
            this.showError('Download Failed', 'There was an error preparing your image for download. Please try again.');
        }
    }
    
    // Draw checkerboard pattern on any canvas
    drawCheckerboardOnCanvas(ctx, width, height) {
        const size = 20;
        const rows = Math.ceil(height / size);
        const cols = Math.ceil(width / size);
        
        ctx.fillStyle = '#e5e5e5';
        ctx.fillRect(0, 0, width, height);
        
        ctx.fillStyle = '#cccccc';
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if ((x + y) % 2 === 0) {
                    ctx.fillRect(
                        x * size, 
                        y * size, 
                        size, 
                        size
                    );
                }
            }
        }
    }
    
    // Apply watermark to any canvas
    applyWatermarkToCanvas(ctx, width, height) {
        const watermarkType = document.querySelector('input[name="watermarkType"]:checked').value;
        
        if (watermarkType === 'text') {
            this.applyTextWatermarkToCanvas(ctx, width, height);
        } else if (watermarkType === 'image' && this.watermarkImage) {
            this.applyImageWatermarkToCanvas(ctx, width, height);
        }
    }
    
    // Apply text watermark to any canvas
    applyTextWatermarkToCanvas(ctx, width, height) {
        const text = this.watermarkText.value || 'ProCut';
        const color = this.watermarkColor.value;
        const opacity = parseInt(this.watermarkOpacity.value) / 100;
        
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.fillStyle = color;
        
        // Scale font size based on image dimensions
        const fontSize = Math.max(24, width * 0.03);
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Calculate position (center)
        const x = width / 2;
        const y = height / 2;
        
        // Add text shadow for better visibility
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 5;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        ctx.fillText(text, x, y);
        ctx.restore();
    }
    
    // Apply image watermark to any canvas
    applyImageWatermarkToCanvas(ctx, width, height) {
        if (!this.watermarkImage) return;
        
        const opacity = parseInt(this.watermarkOpacity.value) / 100;
        
        // Calculate dimensions (20% of canvas width, maintain aspect ratio)
        const maxWidth = width * 0.2;
        const ratio = maxWidth / this.watermarkImage.width;
        const wWidth = maxWidth;
        const wHeight = this.watermarkImage.height * ratio;
        
        // Position (bottom right with 10px margin)
        const x = width - wWidth - 10;
        const y = height - wHeight - 10;
        
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.drawImage(this.watermarkImage, x, y, wWidth, wHeight);
        ctx.restore();
    }
    
    // Reset the tool to initial state
    resetTool() {
        this.uploadZone.classList.remove('hidden');
        this.processingArea.classList.add('hidden');
        this.actionButtons.classList.add('hidden');
        this.currentImage = null;
        this.originalImageData = null;
        this.processedImageData = null;
        this.maskData = null;
        this.actionHistory = [];
        this.currentHistoryIndex = -1;
        this.fileInput.value = '';
        this.resetZoom();
        this.updateUndoRedoButtons();
    }
    
    // Show loading overlay
    showLoading(message) {
        this.loadingSubtext.textContent = message || 'Processing your image...';
        this.loadingOverlay.classList.remove('hidden');
    }
    
    // Hide loading overlay
    hideLoading() {
        this.loadingOverlay.classList.add('hidden');
    }
    
    // Show error modal
    showError(title, message) {
        this.errorTitle.textContent = title;
        this.errorMessage.textContent = message;
        this.errorModal.classList.remove('hidden');
    }
}

// Initialize the application when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    const app = new BackgroundRemover();
    
    // Add any global event listeners or initializations here
    window.addEventListener('resize', () => {
        // Handle resize if needed
    });
});
